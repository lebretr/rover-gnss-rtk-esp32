/* Use this Code with ESP32 Wemos D1 Mini or any board with a Wroom 32 module
   Can be compiled with board library esp32 expressif V3.0.5
   This works up to 460800bps or higher
   Optimized by me Oct 24
*/

#include <BLEDevice.h>         // Library for BLE Bluetooth
#include <BLE2902.h>
#include <esp_task_wdt.h>

// ************************ Set up the following details to suit your configuration

// Set up gnss pins
#define TX1_PIN 17                
#define RX1_PIN 16                 // Don't use 0 for RX, some devices can't drive it


#define BT_BLE_NAME      "TEST_RTK"  // Name of the ESP32 BT for Android or BLE for iOS

#define GNSS_BAUDRATE 115200 //460800
#define CONSOLE_RATE  115200

// *************************** End of configuration


// BLE UUIDs for the Nordic GNSS Service (NUS)
#define SERVICE_UUID           "6E400001-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_RX "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_TX "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"

// Watchdog timeout in seconds
#define WDT_TIMEOUT 60

BLEServer* pServer = NULL;
BLECharacteristic* pTxCharacteristic = NULL;
BLECharacteristic* pRxCharacteristic = NULL;
bool bleDeviceConnected = false;
bool oldBleDeviceConnected = false;


// Callback class for BLE for connected/disconnected states
class MyServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      bleDeviceConnected = true;
      Serial.println("BLE device connected.");
    };
    void onDisconnect(BLEServer* pServer) {
      bleDeviceConnected = false;
      Serial.println("BLE device disconnected.");
    }
};
// Callback class for BLE sending data to GNSS
class MyCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic* pCharacteristic) override {
        String value = pCharacteristic->getValue();
        if (value.length() > 0) {
            Serial1.write((uint8_t*)value.c_str(), value.length());
        }
    }
};

void setup() {
  Serial.begin(CONSOLE_RATE);

  esp_task_wdt_config_t config = {
    .timeout_ms = WDT_TIMEOUT * 1000,
    .trigger_panic = true,      // Trigger panic if watchdog timer is not reset
  };
  esp_task_wdt_reconfigure(&config);
  esp_task_wdt_add(NULL);       // Add the current task to the watchdog

  // Initialize GNSS with baud rate
  Serial1.begin(GNSS_BAUDRATE, SERIAL_8N1, RX1_PIN, TX1_PIN);


  // BLE initialization for IOS devices
  BLEDevice::init(BT_BLE_NAME); 
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());
  BLEService* pService = pServer->createService(SERVICE_UUID);
  pTxCharacteristic = pService->createCharacteristic(
                        CHARACTERISTIC_UUID_TX,
                        BLECharacteristic::PROPERTY_READ |
                        BLECharacteristic::PROPERTY_NOTIFY
                      );
  pTxCharacteristic->addDescriptor(new BLE2902());
  pRxCharacteristic = pService->createCharacteristic(
                        CHARACTERISTIC_UUID_RX,
                        BLECharacteristic::PROPERTY_WRITE
                      );
  pRxCharacteristic->setCallbacks(new MyCallbacks());
  pService->start();
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);  
  pAdvertising->setMinPreferred(0x12);
  pAdvertising->start();
  Serial.println("BLE started and advertising sent.");

  // Start the GNSS task on 2nd core
  xTaskCreatePinnedToCore(gnssTask, "GNSS Task", 8192, NULL, 1, NULL, 1);
}

void loop() {                         // Lower priority tasks
  // Check the BLE states for disconnection
  if (bleDeviceConnected && !oldBleDeviceConnected) {
    oldBleDeviceConnected = bleDeviceConnected;
  }
  if (!bleDeviceConnected && oldBleDeviceConnected) {
    oldBleDeviceConnected = bleDeviceConnected;
    pServer->startAdvertising();
    Serial.println("Advertising restarted.");
  }

  esp_task_wdt_reset();  // Watchdog reset
}

// Function for the GNSS task
void gnssTask(void *pvParameters) {
  while (true) {
    // Receive data from GNSS and forward to BLE (iOS) or Bluetooth device (Android)
    while (Serial1.available()) {
      size_t len = Serial1.available();
      uint8_t buffer[len];
      Serial1.readBytes(buffer, len);
      
      if (bleDeviceConnected) {
        pTxCharacteristic->setValue(buffer, len);
        pTxCharacteristic->notify(); // Send data to connected iOS device
        sentOnce = false;
      } else {
        if (sentOnce == false) {            // Only send message once per disconnect
          Serial.println("No BLE or BT device connected. Data not being sent.");
          sentOnce = true;
        }
      }
    }
  }
}
